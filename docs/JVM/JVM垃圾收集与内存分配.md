# 堆空间基本结构

在学习垃圾收集器之前，我们先了解一下堆空间的结构

![堆空间基本结构](https://raw.githubusercontent.com/ImmortalCountry/BlogPhotos/master/%E5%A0%86%E7%A9%BA%E9%97%B4%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png)

- 新生代：Eden 区、Survivor区：s0 区 & s1区；老年代：Tenured 区。
- 过程

1. 大多数情况下，对象首先在 Eden 区域生成
2. 当 Eden 区满时，还存活的对象将被复制到 Survivor 区（两个中的一个）【在一次新生代垃圾回收后，如果对象还存活，则会进入 s1,并且对象的年龄加 1 (Eden 区->Survivor 区后对象的初始年龄变为 1)】
3. 当这个 Survivor 区满时，此区的存活对象将被复制到另外一个 Survivor 区，当这个 Survivor 区也满了的时候，从第一个Survivor（s0）区复制过来的并且此时还存活的对象，将被复制“老年代(Tenured)”。
**注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从 Eden 复制过来对象，和从前一个 Survivor 复制过来的对象，而复制到年老区的只有从第一个 Survivor 区过来的对象。而且，Survivor 区总有一个是空的。同时，根据程序需要，Survivor 区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。**
4. 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认
    为老年代中存放的都是一些生命周期较长的对象。当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。(对象晋升到老年代的年龄阈值，可以通过参数 -`XX:MaxTenuringThreshold` 来设置)
5. **在Java8中移除了永生代，取而代之是元空间(Metaspace)**
```java
  - 移除了永久代（PermGen），替换为元空间（Metaspace）
  - 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）
  - 永久代中的 interned Strings 和 class static variables 转移到了 Java heap
  - 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）
```

# 判断对象是否已死

1. 引用计数算法

- 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加 1；当引用失效时，计数器就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。
- 主流虚拟机一般不采用，因为无法解决循环引用问题。
```java
public class ReferenceCountingGc {
    public Object instance = null;
	public static void main(String[] args) {
		ReferenceCountingGc objA = new ReferenceCountingGc();
		ReferenceCountingGc objB = new ReferenceCountingGc();
		objA.instance = objB;
		objB.instance = objA;
		objA = null;
		objB = null;

	}
}
```

2. 可达性分析算法

![可达性分析算法判定对象是否可回收](https://raw.githubusercontent.com/ImmortalCountry/BlogPhotos/master/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.png)

- 从 一些列叫做 GC Roots 对象作为起始点，往下搜索，路径成为引用链，当一个对象没有任何引用链连到 GC Roots （不可达）即证明对象是不可用的，可回收的。
- 可作为 GC Roots 的对象：
	
	- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
	- 方法区中类静态属性引用的对象。
	- 方法区中常量引用的对象。
	- 本地方法栈中 JNI （即一般说的 Native 方法）引用对象。

## 引用

- 无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。

- JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

- JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用 4 种，这 4 种引用强度依次逐渐减弱。

1. 强引用（StrongReference）
是程序代码中最普遍的存在，如 `Object obj = new Object()` 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。

2. 软引用（SoftReference）
描述一些还有用但非必需的对象。在将要发生内存溢出异常之前，将会进行回收。如果回收后内存还不够，才会抛出异常。如果内存空间足够，垃圾回收器就不会回收它们。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

3. 弱引用（WeakReference）
也用来描述非必需对象。但强度比软引用更弱一点。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存够不够，都会回收弱引用关联的对象（被发现的时候）。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

4. 虚引用（PhantomReference）
也称幽灵引用或者幻影引用，是最弱的一种引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。唯一目的就是能在这个对象被回收时收到一个系统通知。

>虚引用主要用来跟踪对象被垃圾回收的活动。
虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。

## 生存还是死亡？

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；
1. 可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。
2. 被判定为需要执行 finalize 方法的对象将会被放在一个叫 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。（执行不会等待它执行结束，防止死循环下一直等待）然后把 F-Queue 队列中的对象进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。
**任何对象的 finalize 方法只会被执行一次，所以一般对象只能逃脱一次被回收。不建议使用finalize 方法（运行代价大，不确定向大，无法保证各个对象的调用顺序），可以用 try-finally 来实现类似需求**

### 如何判断一个常量是废弃常量

运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是**废弃常量**呢？

假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

**注意：在  JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

### 如何判断一个类是无用的类

方法区主要回收的是无用的类，那么如何判断一个类是**无用的类**的呢？

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就会必然被回收。

# 垃圾收集算法

1. 标记-清除算法
算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
	- 效率低：标记和清除效率都低。
	- 空间问题：产生大量不连续内存碎片。当有大对象来到时，不得不提前触发垃圾收集动作。
2. 复制算法
为解决效率它将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
	- 解决了空间效率问题
	- 代价是将内存缩小一半。
3. 标记-整理算法
根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
4. 分代收集算法
当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
在新生代中，每次收集都会有大量对象死去，少量存活所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

# 垃圾收集器

1. Serial
- 单线程，即必须暂停其他线程等待垃圾回收结束。
- 新生代采用复制算法，老年代采用标记-整理算法。
- 简单而高效（与其他收集器的单线程相比）Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 **Client** 模式下的虚拟机来说是个不错的选择。

2. ParNew
- ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。
- 新生代采用复制算法，老年代采用标记-整理算法。
- 它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

3. Parallel Scavenge
- Parallel Scavenge 收集器也是使用复制算法的多线程收集器
- 新生代采用复制算法，老年代采用标记-整理算法。 
- Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。

4. CMS
- CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。
- CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。
- 标记-清除算法实现整个过程分为四个步骤：
	1. 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
	2. 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
	3. 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
	4. 并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。
	5. 主要优点：并发收集、低停顿
	6. 缺点：
		- 对 CPU 资源敏感；
		- 无法处理浮动垃圾；
		- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

5. G1
- G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。
- 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- 空间整合：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
- 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。
- G1 收集器的运作大致分为以下几个步骤：
	- 初始标记
	- 并发标记
	- 最终标记
	- 筛选回收
- G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

**并行与并发：**

* 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
* 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

```java
-XX:+UseParallelGC 

    使用 Parallel 收集器+ 老年代串行

-XX:+UseParallelOldGC

    使用 Parallel 收集器+ 老年代并行
```

## 参考
- 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》
- https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md#25-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F












