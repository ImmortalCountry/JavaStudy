# 什么是 IOC？

IOC—Inversion of Control，即“控制反转”，是一种设计思想。
IOC 即将你设计好的类交给容器去控制管理，比如 new 一个对象，不需要你去 new 而是容器给你生成，并进行管理。

理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转），哪些方面反转了”，那我们来深入分析一下：

## 谁控制谁，控制什么？

IOC容器控制对象；控制了外部资源获取

## 什么是反转？在哪些方面？

因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；

哪些方面反转了？依赖对象的获取被反转了。

正转：在程序中主动创建依赖对象。

反转：由IOC容器创建对象，进行依赖注入。

## IOC好处

思想上发生转变，从应用程序决定获取资源，变成了IOC容器来给你注入，给你啥你就要啥。

## IOC 和 DI

DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在**运行期**决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。

依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。
通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。

理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：

　　●谁依赖于谁：应用程序依赖于IOC容器；

　　●为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源；

　　●谁注入谁：IOC容器注入应用程序某个对象，应用程序依赖的对象；
　　
　　●注入了什么：注入某个对象所需要的外部资源（包括对象、资源、常量数据）。

### IOC和DI由什么关系呢？

它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IOC 而言，“依赖注入”明确描述了“被注入对象依赖IOC容器配置依赖对象”。

**依赖注入，前提必须有IOC的环境，Spring管理这个类的时候将类的依赖的属性注入（设置）进来。**

# 注入方式

从注入方法上看，主要可以划分为三种类型：构造函数注入、属性注入和接口注入。Spring支持构造函数注入和属性注入。

**若采用属性注入方式一定要实现set方法**

# 没采用控制反转的缺点

1. 接口与实现类有耦合。
2. 接口 引用 = new 实现类1, 若想换实现类2了，就得必须改源代码，所以切换底层实现类很方便。

如 MySQL 换 Oracle

# IOC底层原理
![IOC底层原理](https://raw.githubusercontent.com/ImmortalCountry/BlogPhotos/master/IOC%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861.png)

[谈谈对 Spring IOC 的理解](https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fqq_22654611%2Farticle%2Fdetails%2F52606960%2F)

