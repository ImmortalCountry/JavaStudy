## 请求转发和请求重定向

### 重定向

```java
	/*
		之前的写法
		response.setStatus(302);
		response.setHeader("Location", "login_success.html");
	*/

	// 重定向写法： 重新定位方向 参数即跳转的位置
	response.sendRedirect("login_success.html");
```

1. 地址上显示的是最后的那个资源的路径地址
	
2. 请求次数最少有两次， 服务器在第一次请求后，会返回302 以及一个地址， 浏览器在根据这个地址，执行第二次访问。
	
3. 可以跳转到任意路径。 不是自己的工程也可以跳。
	
4. 效率稍微低一点， 执行两次请求。 
	
5. 后续的请求，没法使用上一次的request存储的数据，或者 没法使用上一次的request对象，因为这是两次不同的请求。

### 请求转发

```java
	//请求转发的写法： 参数即跳转的位置
	request.getRequestDispatcher("login_success.html").forward(request, response);
```

1. 地址上显示的是请求servlet的地址。  返回200 ok

2. 请求次数只有一次， 因为是服务器内部帮客户端执行了后续的工作。 

3. 只能跳转自己项目的资源路径 。  

4. 效率上稍微高一点，因为只执行一次请求。 

5. 可以使用上一次的request对象。 

#### 在JSP中

```xml
	在jsp页面中你也会看到通过下面的方式实现转发：
	<jsp:forward page="apage.jsp" />

	当然也可以在jsp页面中实现重定向：
	<%response.sendRedirect("new.jsp");//重定向到new.jsp%>
```

### 本质区别

#### 一：

>一句话，转发是服务器行为，重定向是客户端行为。为什么这样说呢，这就要看两个动作的工作流程：
>**转发过程：**客户浏览器发送http请求----》web服务器接受此请求--》调用内部的一个方法在容器内部完成请求处理和转发动作----》将目标资源发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。
>
>**重定向过程：**客户浏览器发送http请求----》web服务器接受后发送302状态码响应及对应新的location给客户浏览器--》客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址----》服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。

#### 二：

> 重定向，其实是两次request,
> 第一次，客户端request   A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。**在重定向的过程中，传输的信息会被丢失。**

#### 三：

> 假设你去办理某个执照，
>
>重定向：你先去了A局，A局的人说：“这个事情不归我们管，去B局”，然后，你就从A退了出来，自己乘车去了B局。
>
>转发：你先去了A局，A局看了以后，知道这个事情其实应该B局来管，但是他没有把你退回来，而是让你坐一会儿，自己到后面办公室联系了B的人，让他们办好后，送了过来。

![img01](\resource\img01.png)

